<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DocScan â€” Recherche instantanÃ©e</title>

  <!--
    PDF.js 3.x  â€” extraction texte natif
    Tesseract.js 4.x â€” OCR images, workers via blob: (fonctionne dans tout navigateur standard)
    NOTE : la prÃ©visualisation dans claude.ai bloque les blob: workers (sandbox iframe).
           Sur Vercel ou tout autre hÃ©bergement normal, tout fonctionne parfaitement.
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.4/dist/tesseract.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&family=DM+Mono:ital,wght@0,400;0,500;1,400&display=swap');

    :root {
      --bg: #071a1e;
      --surface: #0d2a30;
      --border: #1a4a52;
      --accent: #2dd4bf;
      --accent2: #0891b2;
      --text: #e0f4f5;
      --muted: #4d8a92;
      --success: #34d1a0;
      --radius: 4px;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      background-image:
        radial-gradient(ellipse at 20% 0%, #0d3a42 0%, transparent 60%),
        radial-gradient(ellipse at 80% 100%, #062830 0%, transparent 50%);
      color: var(--text);
      font-family: 'DM Mono', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.5rem 2.5rem;
      border-bottom: 1px solid var(--border);
      display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;
    }
    .logo {
      font-family: 'Syne', sans-serif; font-weight: 800; font-size: 1.9rem;
      letter-spacing: -0.03em; color: var(--accent); line-height: 1;
    }
    .logo span { color: var(--accent2); }
    .tagline { font-size: 0.7rem; color: var(--muted); letter-spacing: 0.1em; text-transform: uppercase; }
    .privacy-badge {
      margin-left: auto; font-size: 0.63rem; letter-spacing: 0.08em; text-transform: uppercase;
      color: var(--success); border: 1px solid var(--success); padding: 0.28rem 0.65rem; border-radius: 2px;
    }

    main {
      flex: 1; display: grid;
      grid-template-columns: minmax(0,1fr) minmax(0,1fr);
      grid-template-rows: auto 1fr;
      min-height: 0;
    }

    .search-section {
      grid-column: 1 / -1; padding: 1.2rem 2.5rem;
      border-bottom: 1px solid var(--border); display: flex; gap: 1rem; align-items: center;
    }
    .search-wrap { flex: 1; position: relative; }
    .search-wrap::before {
      content: '>'; position: absolute; left: 1rem; top: 50%; transform: translateY(-50%);
      color: var(--accent); pointer-events: none;
    }
    #searchInput {
      width: 100%; background: var(--surface); border: 1px solid var(--border);
      color: var(--text); font-family: 'DM Mono', monospace; font-size: 1.05rem;
      padding: 0.85rem 1rem 0.85rem 2.5rem; border-radius: var(--radius);
      outline: none; transition: border-color 0.2s;
    }
    #searchInput:focus { border-color: var(--accent); }
    #searchInput::placeholder { color: var(--muted); }
    .stats-bar { font-size: 0.68rem; color: var(--muted); white-space: nowrap; }
    .stats-bar .hit { color: var(--accent); font-weight: 700; }

    .drop-section {
      border-right: 1px solid var(--border); padding: 1.5rem 2rem;
      display: flex; flex-direction: column; gap: 1.2rem; overflow-y: auto;
    }
    #dropZone {
      border: 2px dashed var(--border); border-radius: var(--radius);
      padding: 2.5rem 1.5rem; text-align: center; cursor: pointer;
      transition: border-color 0.2s, background 0.2s; position: relative; flex-shrink: 0;
    }
    #dropZone.dragover { border-color: var(--accent); background: rgba(45,212,191,0.04); }
    #dropZone input { position: absolute; inset: 0; opacity: 0; cursor: pointer; width: 100%; height: 100%; }
    .drop-icon { font-size: 2.2rem; margin-bottom: 0.6rem; }
    .drop-label { font-size: 0.78rem; color: var(--muted); line-height: 1.6; }
    .drop-label strong { color: var(--accent); }
    .drop-formats { margin-top: 0.4rem; font-size: 0.62rem; color: #1a5a65; letter-spacing: 0.08em; text-transform: uppercase; }

    .section-title { font-size: 0.62rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--muted); }
    #fileList { display: flex; flex-direction: column; gap: 0.45rem; }

    .file-item {
      display: flex; align-items: center; gap: 0.7rem; padding: 0.6rem 0.85rem;
      background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
      transition: border-color 0.3s;
    }
    .file-item.indexing { border-color: #1a4a52; }
    .file-item.ready    { border-color: var(--success); }
    .file-item.error    { border-color: #ef4444; }
    .file-ext {
      font-size: 0.58rem; font-weight: 600; text-transform: uppercase; padding: 0.18rem 0.38rem;
      border-radius: 2px; background: #091e24; color: var(--muted);
      flex-shrink: 0; min-width: 2.3rem; text-align: center;
    }
    .file-name { flex: 1; font-size: 0.75rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .file-status { font-size: 0.62rem; flex-shrink: 0; }
    .file-status.indexing { color: var(--muted); }
    .file-status.ready    { color: var(--success); }
    .file-status.error    { color: #ef4444; }
    .file-remove {
      background: none; border: none; color: #1a5560; cursor: pointer;
      font-size: 0.85rem; padding: 0 0.15rem; transition: color 0.2s; flex-shrink: 0;
    }
    .file-remove:hover { color: #ef4444; }

    .ocr-progress {
      font-size: 0.58rem; color: var(--muted); margin-top: 0.2rem;
      height: 2px; background: var(--border); border-radius: 1px; overflow: hidden;
    }
    .ocr-progress-fill { height: 100%; background: var(--accent); transition: width 0.3s; }

    .results-section {
      padding: 1.5rem 2rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.9rem;
    }
    #resultsList { display: flex; flex-direction: column; gap: 0.65rem; }
    .result-card {
      background: var(--surface); border: 1px solid var(--border);
      border-radius: var(--radius); overflow: hidden; animation: fadeIn 0.18s ease;
    }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(3px); } to { opacity: 1; } }
    .result-card.matched { border-color: var(--accent); }
    .result-header { display: flex; align-items: center; gap: 0.7rem; padding: 0.65rem 0.9rem; border-bottom: 1px solid var(--border); }
    .result-filename { flex: 1; font-size: 0.8rem; font-weight: 500; }
    .result-count { font-size: 0.68rem; background: var(--accent); color: #071a1e; padding: 0.18rem 0.45rem; border-radius: 2px; font-weight: 700; }
    .result-count.zero { background: transparent; color: var(--muted); border: 1px solid var(--border); font-weight: 400; }
    .result-snippets { padding: 0.65rem 0.9rem; display: flex; flex-direction: column; gap: 0.45rem; }
    .snippet { font-size: 0.72rem; color: #7ab8bf; line-height: 1.6; border-left: 2px solid var(--border); padding-left: 0.7rem; }
    .snippet mark { background: var(--accent); color: #071a1e; padding: 0 0.12rem; border-radius: 1px; }
    .snippet-page { font-size: 0.58rem; color: var(--muted); margin-bottom: 0.18rem; letter-spacing: 0.05em; text-transform: uppercase; }

    .empty-state { text-align: center; padding: 2.5rem 2rem; color: var(--muted); font-size: 0.78rem; line-height: 1.9; }
    .empty-state .big { font-size: 1.8rem; margin-bottom: 0.8rem; }

    .spinner {
      display: inline-block; width: 9px; height: 9px;
      border: 2px solid var(--border); border-top-color: var(--accent);
      border-radius: 50%; animation: spin 0.55s linear infinite; vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    footer {
      border-top: 1px solid var(--border); padding: 0.65rem 2.5rem;
      display: flex; gap: 2rem; font-size: 0.6rem; color: #2a6570; letter-spacing: 0.04em;
    }
    footer span { color: #3a7a85; }

    @media (max-width: 768px) {
      main { grid-template-columns: 1fr; }
      .drop-section { border-right: none; border-bottom: 1px solid var(--border); }
    }
  </style>
</head>
<body>

<header>
  <div class="logo">Doc<span>Scan</span></div>
  <div class="tagline">Recherche instantanÃ©e dans vos documents</div>
  <div class="privacy-badge">âœ“ 100% local â€” rien enregistrÃ©</div>
</header>

<main>
  <div class="search-section">
    <div class="search-wrap">
      <input type="text" id="searchInput" placeholder="Rechercher un mot, une date, un code..." autocomplete="off" spellcheck="false" />
    </div>
    <div class="stats-bar" id="statsBar">â€” aucun document chargÃ©</div>
  </div>

  <div class="drop-section">
    <div id="dropZone">
      <input type="file" id="fileInput" multiple accept=".pdf,.png,.jpg,.jpeg,.gif,.webp,.bmp,.tif,.tiff,.txt,.csv,.md,.html" />
      <div class="drop-icon">ğŸ“‚</div>
      <div class="drop-label"><strong>Glissez vos fichiers ici</strong><br>ou cliquez pour sÃ©lectionner</div>
      <div class="drop-formats">PDF Â· JPG Â· PNG Â· GIF Â· WEBP Â· TXT Â· CSV Â· MD</div>
    </div>
    <div class="section-title">Documents chargÃ©s</div>
    <div id="fileList">
      <div class="empty-state" style="padding:0.8rem;font-size:0.72rem;">Aucun document pour l'instant.</div>
    </div>
  </div>

  <div class="results-section">
    <div class="section-title">RÃ©sultats</div>
    <div id="resultsList">
      <div class="empty-state">
        <div class="big">ğŸ”</div>
        Glissez des documents puis tapez votre recherche.<br>
        Les rÃ©sultats apparaissent instantanÃ©ment.
      </div>
    </div>
  </div>
</main>

<footer>
  <span>DocScan</span>
  Traitement 100% local dans votre navigateur Â·
  PDF.js (texte natif) + Tesseract.js (OCR images &amp; PDF scannÃ©s) Â·
  Fermez l'onglet pour tout effacer
</footer>

<script>
// â”€â”€ PDF.js worker depuis CDN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pdfjsLib.GlobalWorkerOptions.workerSrc =
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// â”€â”€ Tesseract worker (crÃ©Ã© une seule fois, rÃ©utilisÃ©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let tessWorker = null;

async function getTessWorker() {
  if (tessWorker) return tessWorker;
  tessWorker = await Tesseract.createWorker('fra+eng', 1, {
    workerPath:  'https://cdn.jsdelivr.net/npm/tesseract.js@4.1.4/dist/worker.min.js',
    corePath:    'https://cdn.jsdelivr.net/npm/tesseract.js-core@4.0.4/tesseract-core-simd-lstm.wasm.js',
    langPath:    'https://tessdata.projectnaptha.com/4.0.0_fast',
    logger:      m => {
      if (m.status === 'recognizing text') {
        updateOcrProgress(currentOcrId, Math.round(m.progress * 100));
      }
    }
  });
  return tessWorker;
}

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const docs = {};
let docIdCounter  = 0;
let searchTimeout = null;
let currentOcrId  = null;

// â”€â”€ DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const dropZone    = document.getElementById('dropZone');
const fileInput   = document.getElementById('fileInput');
const fileListEl  = document.getElementById('fileList');
const searchInput = document.getElementById('searchInput');
const resultsList = document.getElementById('resultsList');
const statsBar    = document.getElementById('statsBar');

// â”€â”€ Drag & drop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault(); dropZone.classList.remove('dragover');
  handleFiles(Array.from(e.dataTransfer.files));
});
fileInput.addEventListener('change', () => {
  handleFiles(Array.from(fileInput.files)); fileInput.value = '';
});

// â”€â”€ File dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function handleFiles(files) {
  for (const file of files) {
    const id  = ++docIdCounter;
    const ext = file.name.split('.').pop().toLowerCase();
    docs[id]  = { id, name: file.name, ext, text: '', pages: [], status: 'indexing', ocrProgress: 0 };
    renderFileList();
    try {
      await processFile(id, file, ext);
      docs[id].status = 'ready';
    } catch (err) {
      console.error('DocScan:', err);
      docs[id].status = 'error';
    }
    renderFileList();
    runSearch();
  }
}

async function processFile(id, file, ext) {
  if (ext === 'pdf') {
    await processPDF(id, file);
  } else if (['txt','csv','md','html','htm'].includes(ext)) {
    await processText(id, file);
  } else {
    await processImage(id, file);
  }
}

// â”€â”€ PDF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function processPDF(id, file) {
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
  const pages = [];
  let fullText = '';

  for (let p = 1; p <= pdf.numPages; p++) {
    const page    = await pdf.getPage(p);
    const content = await page.getTextContent();
    const text    = content.items.map(i => i.str).join(' ').trim();
    pages.push({ page: p, text });
    fullText += ' ' + text;
  }

  // PDF natif avec vrai texte
  if (fullText.replace(/\s+/g, '').length > 80) {
    docs[id].pages = pages;
    docs[id].text  = fullText.trim();
    return;
  }

  // PDF scannÃ© â†’ rasteriser chaque page â†’ OCR
  const ocrPages = [];
  for (let p = 1; p <= Math.min(pdf.numPages, 15); p++) {
    const page     = await pdf.getPage(p);
    const viewport = page.getViewport({ scale: 2.0 });
    const canvas   = document.createElement('canvas');
    canvas.width   = viewport.width;
    canvas.height  = viewport.height;
    await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
    const text = await runOCR(id, canvas);
    ocrPages.push({ page: p, text });
  }
  docs[id].pages = ocrPages;
  docs[id].text  = ocrPages.map(p => p.text).join(' ');
}

// â”€â”€ Image â†’ OCR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function processImage(id, file) {
  // Pour GIF/BMP/TIFF : passer par canvas pour normaliser en PNG
  const ext = file.name.split('.').pop().toLowerCase();
  if (['gif','bmp','tiff','tif'].includes(ext)) {
    const canvas = await fileToCanvas(file);
    const text   = await runOCR(id, canvas);
    docs[id].pages = [{ page: 1, text }];
    docs[id].text  = text;
  } else {
    const text = await runOCR(id, file);
    docs[id].pages = [{ page: 1, text }];
    docs[id].text  = text;
  }
}

function fileToCanvas(file) {
  return new Promise((res, rej) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      const c = document.createElement('canvas');
      c.width = img.naturalWidth; c.height = img.naturalHeight;
      c.getContext('2d').drawImage(img, 0, 0);
      URL.revokeObjectURL(url);
      res(c);
    };
    img.onerror = rej;
    img.src = url;
  });
}

// â”€â”€ Tesseract OCR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function runOCR(id, source) {
  currentOcrId = id;
  const worker = await getTessWorker();
  const result = await worker.recognize(source);
  currentOcrId = null;
  return result.data.text || '';
}

function updateOcrProgress(id, pct) {
  if (!id) return;
  const bar = document.querySelector(`[data-id="${id}"] .ocr-progress-fill`);
  if (bar) bar.style.width = pct + '%';
  const st = document.querySelector(`[data-id="${id}"] .file-status`);
  if (st) st.textContent = `OCR ${pct}%`;
}

// â”€â”€ Plain text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function processText(id, file) {
  const text = await file.text();
  docs[id].pages = [{ page: 1, text }];
  docs[id].text  = text;
}

// â”€â”€ Render file list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderFileList() {
  const ids = Object.keys(docs);
  if (!ids.length) {
    fileListEl.innerHTML = '<div class="empty-state" style="padding:0.8rem;font-size:0.72rem;">Aucun document pour l\'instant.</div>';
    statsBar.innerHTML = 'â€” aucun document chargÃ©';
    return;
  }
  const ready = ids.filter(id => docs[id].status === 'ready').length;
  statsBar.innerHTML = `<span class="hit">${ready}</span> / ${ids.length} doc${ids.length > 1 ? 's' : ''} indexÃ©${ready > 1 ? 's' : ''}`;
  fileListEl.innerHTML = ids.map(id => {
    const d  = docs[id];
    const st = d.status === 'indexing'
      ? `<span class="spinner"></span> <span class="file-status indexing">lectureâ€¦</span>`
      : d.status === 'ready'
        ? `<span class="file-status ready">âœ“ prÃªt</span>`
        : `<span class="file-status error">âœ— erreur</span>`;
    const bar = d.status === 'indexing'
      ? `<div class="ocr-progress"><div class="ocr-progress-fill" style="width:${d.ocrProgress||0}%"></div></div>`
      : '';
    return `<div class="file-item ${d.status}" data-id="${id}">
      <span class="file-ext">${d.ext}</span>
      <span class="file-name" title="${d.name}">${d.name}</span>
      ${st}
      <button class="file-remove" onclick="removeDoc(${id})" title="Supprimer">âœ•</button>
    </div>${bar}`;
  }).join('');
}

function removeDoc(id) {
  delete docs[id]; renderFileList(); runSearch();
}

// â”€â”€ Search â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
searchInput.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(runSearch, 100);
});

function runSearch() {
  const query = searchInput.value.trim();
  const ids   = Object.keys(docs);

  if (!ids.length) {
    resultsList.innerHTML = '<div class="empty-state"><div class="big">ğŸ”</div>Glissez des documents puis tapez votre recherche.</div>';
    return;
  }
  if (!query) {
    resultsList.innerHTML = '<div class="empty-state"><div class="big">âœï¸</div>Tapez un mot ou une expression<br>pour lancer la recherche.</div>';
    return;
  }

  const re    = new RegExp(escapeRegex(query), 'gi');
  const cards = ids
    .filter(id => docs[id].status === 'ready')
    .map(id => {
      const d = docs[id];
      const matchCount = (d.text.match(re) || []).length;
      return { d, matchCount, snippets: extractSnippets(d, query, 3) };
    })
    .sort((a, b) => b.matchCount - a.matchCount);

  if (!cards.length) {
    resultsList.innerHTML = '<div class="empty-state">Indexation en coursâ€¦ patientez.</div>';
    return;
  }

  const totalHits  = cards.reduce((s, c) => s + c.matchCount, 0);
  const docsHits   = cards.filter(c => c.matchCount > 0).length;
  const readyCount = Object.values(docs).filter(d => d.status === 'ready').length;
  statsBar.innerHTML = `<span class="hit">${totalHits}</span> occurrence${totalHits > 1 ? 's' : ''} dans <span class="hit">${docsHits}</span> doc${docsHits > 1 ? 's' : ''} Â· ${readyCount} indexÃ©${readyCount > 1 ? 's' : ''}`;

  resultsList.innerHTML = cards.map(({ d, matchCount, snippets }) => {
    const matched  = matchCount > 0;
    const countEl  = matched
      ? `<span class="result-count">${matchCount} rÃ©sultat${matchCount > 1 ? 's' : ''}</span>`
      : `<span class="result-count zero">absent</span>`;
    const snipHtml = snippets.map(s =>
      `<div class="snippet"><div class="snippet-page">${s.label}</div>${s.html}</div>`
    ).join('');
    return `<div class="result-card ${matched ? 'matched' : ''}">
      <div class="result-header">
        <span class="file-ext">${d.ext}</span>
        <span class="result-filename">${d.name}</span>
        ${countEl}
      </div>
      ${snipHtml ? `<div class="result-snippets">${snipHtml}</div>` : ''}
    </div>`;
  }).join('');
}

function extractSnippets(doc, query, max) {
  const re = new RegExp(escapeRegex(query), 'gi');
  const snippets = [];
  for (const pg of doc.pages) {
    let m; re.lastIndex = 0;
    while ((m = re.exec(pg.text)) !== null && snippets.length < max) {
      const start = Math.max(0, m.index - 90);
      const end   = Math.min(pg.text.length, m.index + query.length + 90);
      let ex      = pg.text.slice(start, end).replace(/\s+/g, ' ').trim();
      if (start > 0) ex = 'â€¦' + ex;
      if (end < pg.text.length) ex += 'â€¦';
      const html  = ex.replace(new RegExp(escapeRegex(query), 'gi'), x => `<mark>${x}</mark>`);
      snippets.push({ label: doc.pages.length > 1 ? `Page ${pg.page}` : 'Extrait', html });
    }
  }
  return snippets;
}

function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
</script>
</body>
</html>
